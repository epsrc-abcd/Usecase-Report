\section{Preliminaries}
\label{sec:preliminaries}

In this section the basic notions and terms that are used throughout
the paper, are defined and discussed.

\subsection{Session Types: Notions and Terminology}

Session types can be seen as types that describe behaviour.
Typically, a type is broadly understood
as a meta-information concept, which is used describe a class of a data.
Structures of types are used to describe data structures.
When types are structured as input/output requirements they
can be used to describe functionality. The combination of
functionality and data structures give rise to the concept
of classes of objects.
%
A session type extends the above approaches of
the notion of a type to capture the specifics of communication and concurrency.
% definition of session types
{\em A session type is a type structure that describes a communication
behaviour in terms of a series of send and receive message passing
interactions between a set of concurrent entities.}
%

On a more practical perspective a session type may be seen as a
{\em specification} of a communication {\em protocol} among concurrent {\em roles},
that is described in a formal syntax.
The syntax for session types is defined on {\em send} and {\em receive}, and {\em select} and {\em branch}
operators.
Sending and receiving data gives rise to the notion of {\em message passing}.
Messages passed are described via their types.
The case where a data with a session typed is passed as a message
is called {\em session delegation}.
Select and branch define a single interaction called {\em choice}.
Choice requires for a role to use a value called {\em label}
to select a communication behaviour out of a set of behaviours, called {\em branch},
offered by another role.

Session types assume a {\em global} protocol that describes the
communication interaction of all the roles inside a system.
Session types also assume a {\em local} protocol that describes the
communication interaction of a single role with all other roles within the system.

The relation between a global protocol and the
local protocols of its roles, is expressed
through a procedure called {\em projection}.
Projection to a role
%is a procedure that can be done
automatically;
given the global protocol and a role, the projection 
procedure returns as a local protocol only the
interactions of the global protocol that are concerned with
the role.

The reverse procedure from projection is called {\em synthesis},
where a set of local protocols are composed together in a global
protocol.

Typically, a protocol is first expressed globally and then
projected locally on the protocol roles.
The local specification of a role is then
implemented by the program that implements the role
We use the term {\em session fidelity} to express
the conformance of the implementation of a role to the role's
local protocol.

If all the roles inside a concurrent system ensure session
fidelity,
then a number of communication properties can be guaranteed
for the communication behaviour of the system:
\begin{enumerate}[label=$\bullet$]
	\item	At any given time of the execution:
	\begin{itemize}
		\item	{\em Communication operator matching}: Every send (resp., select) operation has a corresponding receive (resp., branch) operation.
		\item	{\em Message type matching}: The type of every received message matches the type of the message expected to be receive.
		\item	{\em Deadlock-freedom}: Every sent messages will be eventually received.
	\end{itemize}
\end{enumerate}

\subsection{Session Types as Protocols: The Scribble Tool-chain}

This section presents the Scribble~\cite{scribble} tool-chain
as the core tool for the application of session types. This section
also uses Scribble to clarify the terminology developed in the
previous section.

The basic module of the Scribble tool-chain is the Scribble
protocol description language, which is a syntax that
expresses session type specifications.
The design of the Scribble language draws directly from
the principles of session types.

In \figref{scribble_bs}, we use the Scribble protocol for the
Bookstore usecase in the online repository~\cite{usecase_repository},
to present the Scribble syntax.

\begin{figure}[t]
\begin{lstlisting}
  global protocol Bookstore(role Buyer1, role Buyer2, role Seller) {
    book(title) from Buyer1 to Seller;
    book(price) from Seller to Buyer1;
    quote(contribution) from Buyer1 to Buyer2;
    choice at Buyer2 {
      agree() fom Buyer2 to Buyer1, Seller;
      transfer(money) from Buyer1 to Seller;
      transfer(money) from Buyer2 to Seller;
    } or {
      quit() from Buyer2 to Buyer1, Seller;
    }
  }
\end{lstlisting}
\caption{Scribble: Global protocol for the Bookstore usecase}
\label{fig:scribble_bs}
\end{figure}

\dk{use consistently term program for local implementation, term system for the concurrent implementation}

Line 1 of \figref{scribble_bs} defines the 
of global protocol \lstinline|Bookstore| between
roles \lstinline|Buyer1|, \lstinline|Buyer2| and \lstinline|Seller|.
%The communication structure is expressed 
%as a sequence of {\em endpoint} to endpoint message passing
%interactions between the roles of the protocol.
%Messages are described in terms of a message type,
%where  a label is used to annotate a list
%of types.
Line 2 gives an example of the simplest endpoint-to-endpoint
message passing interaction,
where role \lstinline|Buyer1| is expected to sends a message with
label \lstinline|book| and type \lstinline|title| to role
\lstinline{Seller}.
In general messages are described as a type structure
consisted of a label and a list of message types.

\dk{describe the choice and the recursion construct}


\begin{figure}[t]
\begin{lstlisting}
local protocol Bookstore at Buyer1(role Buyer1, role Buyer2, role Seller) {
  book(title) to Seller;
  book(price) from Seller;
  quote(contribution) to Buyer2;
  choice at Buyer2 { agree() fom Buyer2; transfer(money) to Seller; }
  or               { quit() from Buyer2; }
}
\end{lstlisting}
	\caption{Local Protocol for Role Buyer1}
\end{figure}


%We use the term {\em local} protocol to describe
%the communication structure at the level of a single participant.
%As session types is a type discipline with the requirement to
%be enforced on a program, we may sometimes refer to a session type
%protocol as communication {\em specification}.

\begin{comment}
For example Scribble code:
%
\begin{lstlisting}
  msg(int) from A to B;
\end{lstlisting}
%
describes the global protocol between role \lstinline|A| and \lstinline|B|,
where participant \lstinline|A| sends message of type \lstinline|msg(int)|
to participant \lstinline|B|. From the local perspective of participant
\lstinline|A| the protocol would be:
%
\begin{lstlisting}
  msg(int) to B;
\end{lstlisting}
%
where it describes the sending of message \lstinline|msg(int)|
to participant \lstinline|B|.
\end{comment}



\subsection{Domain Classification of Usecases}

One of the goals of this paper is to present a diversity
of application of session types from different domains, as
part of our aim to demonstrate the robustness, functionality
and adaptability of session types. Here we present the particular
communication characteristics for every domain.

\dk{Layers of computation: Each domain uses technologies from the previous layers}

\begin{enumerate}
	\item	Network Application/Business Logic:

	\item	Systems

	\item	Network Protocols

	\item	Applications

	\item	Operating System

	\item	Data Structures and Algorithms

	\item	Hardware

	\item	\dk{Security}
\end{enumerate}


\subsection{Usecase Classification on Technologies used}
\dk{Just presentation and references}


\begin{enumerate}
	\item	Session Java - standard binary session types library with compiler support
	\item	Eventful Session Java - event driven parafigm
	\item	Multiparty Session C: a multiparty session type library for MPI  with compiler support
	\item	Monitoring: Session fidelity at runtime. Implemented as a python library - no need for support
	\item	The actors paradigm
			\begin{itemize}
				\item	Implemented in python using the monitor module
				\item	Erlang
			\end{itemize}
	\item	Pabble - MPI: parametric Scribble used to express parametric algorithms and topologies.
	\item	Mungo and StMungo:	based on the OO paradigm a tool that integrates session types and the 
								typestate theory in Java. StMungo transforms Scribble into Mungo
								specifications.
	\item	GV:			A functional programming implementation of binary session types.
	\item	LINKS:		Functional programming based on the linear logic interpretation of session types.
	\item	SILL:		Functional programming based on the linear dual intuitionistic interpretation of session types.

	\item	A state pattern implementation as a library. Uses Scribble to automatically
			create an API for state pattern programming and uses runtime checks to
			cope with linearity requirements.

\end{enumerate}

\subsection{Fine/coarse grain representation}
\dk{this should go as future work}

{\em Concurrency patterns} e.g. network topology, client/server, race condition, etc. (maybe I am writing nonsense here)

