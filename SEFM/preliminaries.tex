\section{Preliminaries}
\label{sec:preliminaries}

Before we proceed with the demonstration of the main thesis
of this paper, we identify the basic notions and set the basic
terminology that we are going to use throughout the paper.

\subsection{Session Types: Notions and Terminology}

Session types can be seen as types that describe behaviour.
Typically, a type is broadly understood
as a concept that carries meta-information to describe a class of a data.
Structures of types are used to describe data structures.
When types are structured as input/output requirements they
can be used to describe functionality. The combination of
functionality and data structures give rise to the concept
of classes of objects.
%
A session type extends the above approaches of
the notion of a type to capture the specifics of communication and concurrency.
A session type is a type structure that describes a communication
behaviour in terms of a series of send and receive interactions between
communicating entities.
In simpler words a session type is a formal specification of a
communication protocol, defined as a structure of send and receive
operations.

%The above definition is used as a basis in \secref{preliminaries}
%to set the basic notions that are used for the presentation of the results
%throughout the paper. Further terminology is being introduced together with
%the introduction of Scribble~\cite{scribble} as a core tool for the definition
%of a session type.


\subsection{Session Types as Protocols: The Scribble Language}

In this section we use Scribble~\cite{scribble} as the core
medium to develop a terminology for presenting session types.
The terminology we use is defined in a non mathematical terms,
as it was the case until now. Instead we use general terms
that are used by a wider computer science community.
Scribble is a protocol description language with its design
drawn directly from the principles of session types.

In \figref{scribble_bs}, we use the Scribble protocol for the
Bookstore usecase in the online repository~\cite{usecase_repository},
to present the Scribble syntax and the terminology for session types.

\begin{figure}[t]
\begin{lstlisting}
  global protocol Bookstore(role Buyer1, role Buyer2, role Seller) {
    book(title) from Buyer1 to Seller;
    book(price) from Seller to Buyer1;
    quote(contribution) from Buyer1 to Buyer2;
    choice at Buyer2 {
      agree() fom Buyer2 to Buyer1, Seller;
      transfer(money) from Buyer1 to Seller;
      transfer(money) from Buyer2 to Seller;
    } or {
      quit() from Buyer2 to Buyer1, Seller;
    }
  }
\end{lstlisting}
\caption{Scribble: Global protocol for the Bookstore usecase}
\label{fig:scribble_bs}
\end{figure}

\dk{Make explicit that session types is message passing communication}

\dk{use consistently term program for local implementation, term system for the concurrent implementation}

Session types are used to express communication
{\em protocols} in terms of {\em structured communication}.
In line 1 of \figref{scribble_bs} we can see the definition 
of global protocol \lstinline|Bookstore| that defines 
the global interactions between roles \lstinline|Buyer1|,
\lstinline|Buyer2| and \lstinline|Seller|.
A {\em global} communication structure is expressed 
as a sequence of {\em endpoint} to endpoint {\em message passing}
interactions between the {\em roles} of the protocol.
Messages are described in terms of a {\em message type},
where  a {\em label} is used to annotate a list
of {\em types}.
Line 2 gives an example of the simplest endpoint-to-endpoint message
passing interaction,
where role \lstinline|Buyer1| {\em sends} a message with
label \lstinline|book| and type \lstinline|title| to role
\lstinline{Seller}.

\dk{describe the choice and the recursion construct}

We use the term {\em local} protocol to describe
the communication structure at the level of a single participant.
As session types is a type discipline with the requirement to
be enforced on a program, we may sometimes refer to a session type
protocol as communication {\em specification}.

\begin{comment}
For example Scribble code:
%
\begin{lstlisting}
  msg(int) from A to B;
\end{lstlisting}
%
describes the global protocol between role \lstinline|A| and \lstinline|B|,
where participant \lstinline|A| sends message of type \lstinline|msg(int)|
to participant \lstinline|B|. From the local perspective of participant
\lstinline|A| the protocol would be:
%
\begin{lstlisting}
  msg(int) to B;
\end{lstlisting}
%
where it describes the sending of message \lstinline|msg(int)|
to participant \lstinline|B|.
\end{comment}

There is a tight relation between a global protocol and the
local protocols of its roles, that is expressed
through called {\em projection}.
Projection to a role is a procedure that can be done automatically;
given the global protocol and a role, the projection 
procedure returns as a local protocol only the
interactions of the global protocol that are concerned with
the role.

The reverse procedure from projection is called {\em synthesis},
where a set of local protocols are composed together in a global
protocol.

Typically, a protocol is first expressed globally and then
projected locally on the protocol roles.
The local specification of a role is then
implemented by the program that implements the role
We use the term {\em session fidelity} to express the fact
that a role implements its corresponding local protocol.

If we can ensure session fidelity among all the roles of a
global protocol that implement their corresponding local protocol,
then a number of communication properties can be ensured
for the communication behaviour of the whole concurrent
system:
\begin{itemize}
	\item	{\em }:	For every send operation there is a matching receive operation.
	\begin{itemize}
		\item	{\em }: The type of the message being send matches the type of
						the message expected to be received.
		\item	{\em }:	Every message send will be eventually received.
		\item	{\em }: There are no communication deadlocks.
	\end{itemize}

\end{itemize}


In terms of properties, session types can ensure, it is proven
that session types ensure

send/receive {\em duality}
{\em deadlock freedom}
{\em type soundness} on the message being passed




\subsection{Domain Classification of Usecases}

One of the goals of this paper is to present a diversity
of application of session types from different domains, as
part of our aim to demonstrate the robustness, functionality
and adaptability of session types. Here we present the particular
communication characteristics for every domain.

\dk{Layers of computation: Each domain uses technologies from the previous layers}

\begin{enumerate}
	\item	Network Application/Business Logic:

	\item	Systems

	\item	Network Protocols

	\item	Applications

	\item	Operating System

	\item	Data Structures and Algorithms

	\item	Hardware

	\item	\dk{Security}
\end{enumerate}


\subsection{Usecase Classification on Technologies used}

\dk{Just presentation and references}

{\em Binary} session types - present it just for academic reasons

{\em Multiparty session types} - overcomes limitation and subsumes binary

{\em Parametric session types} - number of participants as parameter - network topologies

{\em Dynamic session types} - ...

{\em Eventful session types} - ...

{\em Functional session types} - Gay Vasconcelos paper, linear logic interpretation LINKS SILL

{\em Typestate and session types} - ...

{\em Actors} - Python, erlanf

{\em Monitors}

{\em Hybrid}

\subsection{Fine/coarse grain representation}
{\em  fine/coarse grain} representation of a scenario
\dk{put an example}

{\em Concurrency patterns} e.g. network topology, client/server, race condition, etc. (maybe I am writing nonsense here)

