% !TeX root = main.tex

\section{Session Types Tools and Use-Cases}
\label{sec:usecases}

This section firstly gives an overview of a selection of languages and tools based on session types.  We then summarise the use-cases in the ABCD online repository~\cite{usecase_repository} that feature session types.  ... protocol specispecified . It also gives more detailed presentations of two particular use-cases: (1) the bookstore, which was introduced in Section~\ref{sec:session_types} and is a standard example of session types; (2) Simple Mail Transfer Protocol (SMTP), which is a standard network protocol.

\input{figures/fig-usecases}

Table~\ref{table:use_cases_all} lists the name of each use-case, its original source, and the language(s) and/or tool(s) that have been used to implement it. Full source code,
running examples and and detailed descriptiona of all of the use-cases can be found in the repository \cite{usecase_repository}.
The use-cases are organised into application domains and are intended to be representative examples for each domain.


\subsection{Technologies based on Session Types}

Several technologies and tools based on session types have been used to implement the use-cases that we describe in Section~\ref{sec:usecases}.
%
\begin{enumerate}
	\item	Session Java~\cite{HU07TYPE-SAFE} is a Java extension
			that statically checks binary session types for communication channels
			that are implemented as an API.
			%of Java with binary session types for communication channels, supported by a runtime library. The compiler statically checks session types.

	\item	Eventful Session Java~\cite{event} supports asynchronous, event-driven programming, using session types to track progress through individual sessions.

	\item	Multiparty Session C~\cite{NYH12} supports programming in C with the MPI library. The compiler statically checks session types.

	\item	SPY~\cite{DBLP:conf/rv/NeykovaYH13} uses session types for runtime monitoring of communication protocols in Python.

	\item	Two technologies apply session types to the actors paradigm:
			\begin{itemize}
				\item	SPY is used to monitor Python threads that simulate actors~\cite{DBLP:conf/coordination/NeykovaY14}.
%				\item	An implementation that uses SPY to
%						monitor python threads that simulate actors~\cite{DBLP:conf/coordination/NeykovaY14}.
				\item	Session type monitoring is also used for Erlang actors~\cite{SF15}.
%				\item	A similar approach on monitoring session types is also used for the
%						Erlang programming language. %, which is a programming language for the Actors model.
%						\sg{Is this Erlang system one of ours? Simon Fowler's MSc}
			\end{itemize}

	\item	Pabble~\cite{DBLP:conf/pdp/NgY14} extends Scribble to express
			communication structures that are parametrised by the number of roles.
			Pabble protocols are implemented and typechecked for the C+MPI framework.

	\item	Mungo~\cite{mungo} is a tool that integrates session types into the object-oriented
%			programming
			paradigm through the notion of typestate. Communication
			operations on a channel are accessed via a state-dependent interface.
			%Mungo uses a protocol description language for capturing typestate.
			The Scribble to Mungo (StMungo) tool transforms Scribble
			protocols into Mungo interfaces.


	\item	GV:	A functional programming implementation of binary session types~\cite{DBLP:journals/jfp/Wadler14}.

	\item	The web programming language LINKS~\cite{citation_needed}
			uses the linear logic interpretation of session types~\cite{DBLP:journals/jfp/Wadler14}
			to statically type-check protocols.

	\item	The Scribble API generator, automatically creates an API for protocols,
			where it describes each protocol state as a class equipped with
			communication methods. Runtime checks ensure state linearity.

	\item	SILL:		Functional programming based on the linear dual intuitionistic interpretation of session types. \sg{Separate this from the repository --- say something elsewhere.}


\end{enumerate}

\subsection{Application Domains Covered by the Use-Cases}

The use-cases are drawn from a wide range of
application domains, in order to demonstrate that
session types can capture
a broad area of communication specifications.
Covering a wide variety of patterns which allows comparison of features available in the session-based frameworks being evaluated. 
%For the implementation of the usecases in the online
%repository different technologies that integrate
%session types in different programming paradigms were used.

%A taxonomy of domains are presented below with the main
%characteristic that each domain is using technologies from the
%previous domains in the taxonomy. This taxonomy also implies
%a stratification of the application of session types in different
%computation layers.
%%One of the goals of this paper is to present a diversity
%%of application of session types from different domains, as
%%part of our aim to demonstrate the robustness, functionality
%%and adaptability of session types. Here we present the particular
%%communication characteristics for every domain.

\newcommand{\myparagraph}[1]{\paragraph{\noindent\textit{\bf #1\ }}}

\rumi{For each domain explain (1) What are the challenges when implementing Internet Application Protocols?
(2) How Session Types overcome these challenges.  
}

\myparagraph{Internet Application protocols}
This set of use cases is the first step towards more realistic (real-world) applications. 
Implementing Internet application protocols 
The motivation to apply session types verification techniques to Internet Application Protocol is three-fold. 
%: (1) programs should be interropable (2) it may involve untrusted components (3) error-prone specifications. 
 
First, an Internet Application protocol should conform to a semi-informal RFC (request for comments specification). 
RFCs are written in an english prose. As a result specifications are tedious  and error-prone to implement. Second,  the aim of the specification is to enable interaction between heterogeneous systems. Third, implementations often involve untrusted components. 

Session types remove a burden from the developer because they automatically verify that the state of the code follows the state of the protocol. 
Moreover, applying runtime monitor helps protecting the implemented components from interactions with untrusted parties. For example, the SMTP client implementations implemented in Java can interact with any (none session-based) SMTP server implementation.   

%Expresses specific data-structures streaming such as the data-structure of an email,need for translate between RFC text format to/from message/payload types. 

%Benefits of ST usage: interoperability, interaction with non-verified components. Motivation for dynamic monitoring, 
%as well as static verification. They are low-level protocols and thus inherently binary. 
 
\myparagraph{Web Service Application}
Internet Application protocols are often binary. The aim of the use cases presented in this domain is to demonstrate the usage of multi-party protocols. In web services, applications make an extensive use of communications among multiple components and services through a standardised format. Business transactions using web services
are often termed \textit{business protocols} because each of them obeys an agreed-upon conversation structure.
Therefore, a protocol expresses an execution logic for the application. The first two use cases are taken from the specification repository of an official W3C working group set up to establish a domain-specific language for specifying business protocols. 
 
This set of use cases is a practical indication that session types can be used to describe the behavioural logic of an application. The current development of the usecases follows a top-down design approach, where the projection of the global protocol is used by different
implementing technologies.

\myparagraph{Network Topologies and Parallel Algorithms}
The highlights of this domain are: (1) computation and communication are often separated, (2) topologies are scalable and thus parametrised and (3) topologies are reusable, comprising limited set of patterns. 

%X suggests that the goal of computer science should be making parallel computing productive, efficient, correct, portable, and scalable. 
Issues with High Performance Computing (HPC) programmers productivity and programs correctness has long been recognised. A survey among MPI (the de facto standard programming model for HPC) programmers \cite{MPIErrors} ranks \textit{communication mismatches} as the most common errors. Communication mismatches include: (1) Send/receive inconsistency caused by an error in program execution flow) and (2) Send/receive inconsistency caused by incorrect sender and/or receiver specified for a message. 

%Parallel algorithms require threads that communicate. Session types can use describe the necessary underlying communication between threads that implement parallel algorithms.	 

So far we have examined use cases, where the number of interacting parties is fixed. Network Topologies, however, often involve unknown number of participants. 
% Pattern-based structured parallel programming motivates the need for specifications of flexible topologies.  
Pabble is an extension of Scribble with parameterised roles, thus enabling expressing flexible topologies with unknown number of participants. We evaluate the applicability and usability of session types on a well-known set of patterns for parallel programming. Pabble can express all structured patterns in the HPC (High Performance Computing) Dwarf benchmark suit. Dwarf suit captures common patterns of communication and computation. %The Seven Dwarfs, constitute equivalence classes where membership in a class is defined by similarity in computation and data movement. 
The dwarfs are specified at a high level of abstraction to allow reasoning about their behavior across a broad range of applications. Programs that are members of a particular class can be implemented differently and the underlying numerical methods may change over time, but the claim is that the underlying patterns have persisted through generations of changes and will remain important into the future. 
%The dwarfs present a method for capturing the common requirements of classes of applications while being reasonably divorced from individual implementations. 

Applying session types  workflow, in particular generating MPI code form well-established patterns, has shown to improve developer productivity. It saves development and debugging efforts for MPI parallel applications, especially for novice parallel programmers.  

\myparagraph{Classic Concurrency Problems}
%A common source of errors in actor programs is the lack of common specification language for interactions \cite{}. 

Coordination of processes is a challenging problem when implementing concurrent systems. 
A study in \cite{ActorCoordinationStudy} points out that "the property of no shared space and asynchronous
communication can make implementing coordination protocols harder and providing a language
for coordinating protocols is needed". The problem is best exemplified when implementing classic concurrency problems. 

Classic concurrency problems require correct coordination among multiple components to avoid starvation and deadlock. Preserving the causalities between the interactions is challenging since the communication often involves complex patterns, combining long sequence of interactions with recursive behaviour and nested choice branches.
Often precise message sequence should be followed. Moreover, it is not obvious if the components can be safely composed. Sending the wrong message type, sending to the wrong role or not sending in the correct message sequence may lead to deadlocks, errors which initial cause is hard to be identified or wrong computation results.

%The paper reveals that the coordination of processes is a challenging problem when implementing, and especially when scaling up concurrent systems. 

Modelling interactions between components with session types ensures correct synchronisation and prevents deadlocks, unexpected termination and orphan messages. 

%\myparagraph{Other Domains}
%
%{\em Operating System}.
%	Another domain where session types can be applied to
%	is the description of the communication specifics
%	of operating system algorithms and routines, that
%	co-ordinate the usage of hardware resources.
%
%	\mybf{- Locks: Basic OS structure basic for achieving resource utilisation. Its
%		usage implies race conditions that in turn imply asynchronous
%		and reactive communication. The implementation of locks in the
%		eventful session Java shows that session types can express deadlocks.}
%       
%
%{\em Data Structures and Algorithms}.
%	The above layers are using data structures and algorithms.
%	Session types can express the communication
%	concurrent algorithms are using. Furthermore, session types
%	can express the interaction with data structures.
%
%	\mybf{- Collection: A stack client protocol. Used to control the put, get access
%		to a collection structure - when the stack is empty there is not get.
%		Session types describe the logic/properties that a data structure can have.}
%
%	\mybf{- File Access: Similarly used to control the access on a file. Cannot
%		read from a file if the file is not open first and if the file is empty.
%		The protocols ends by closing the file. Again access to resources
%		can be described using session types.}
%{\em Hardware}.
%	Hardware mechanisms complete the stratification of domains.
%	The communication of hardware modules may also be expressed
%	using session types.
%
%	\mybf{- Memory Coherency: Hardware components communicate, here we have two memories
%		that need to be consistent with each other on a hardware level. Session types can
%		describe the hardware (signals/messages) interaction between hardware components.}
%
%{\em Security}.
%	Session types can also find applications in the security domain,
%	which is a domain that supports all other domains in the above list.
%
%	\mybf{- There are some security protocols in the SILL repository. We need to
%			be careful in the description because it is a reference to other people.}
