% !TeX root = main.tex

\section{Use-Cases}
\label{sec:usecases}

This section summarises the use-cases in the ABCD online repository~\cite{usecase_repository} that feature session types. First,  we describe several use case categories, and their differing characteristics wrt. session types specification.  We then outline details of a selection of individual use cases, and go into more depth on two particular use-cases: (1) the bookstore, a standard session types example introduced in Section~\ref{sec:session_types} commly found in the literature; and (2) Simple Mail Transfer Protocol (SMTP), a standardised Internet application protocol.

Table~\ref{table:use_cases_all} lists the name of each use-case, its original source, and the language(s) and tool(s) that have been used to implement it. Full source code, running examples and and detailed descriptiona of all of the use-cases can be found in the repository \cite{usecase_repository}.  The use-cases are organised into application domains and are intended to be representative examples for each domain.

\input{figures/fig-usecases}


\subsection{Application Domains Covered by the Use-Cases}

The use-cases are drawn from a wide range of
application domains, in order to demonstrate that
session types can capture
a broad area of communication specifications and a wide variety of patterns. On  one hand, applying session types to diversity of use cases demonstrates a range of features and extension in the tools. 

On the other  hand, each domain offers appreciation of session types from a different perspective. We explain the specific challenges tackled by session types when applied to a specific domain.   %In this section we demonstrate that depending on the domain the properties are important to a various degree. 
%Each domain has its own challenges and although session types provide multiple guarantees, the motivation to apply session types to a specific domain is slightly different.   
Communication safety guarantees are essential when programming in an error-prone environment (as in High Performance Computing). Session fidelity guarantee is essential when protocols are specified in a semi-formal format (as in Internet Application Protocols). Ensuring progress is challenging when a complex coordination of multiple parties is required (as is Web Services) and compositionality is not apparent (as in Classic Concurrency Problems).

%As we have already explained, session types ensure multiple properties. Here we review session types properties wrt. thir importance when implementing use cases in different domains. 
%We have identified domains that offer a different viewpoint and appreciation of the properties. 
%This is essential when dealing with concurrent algorithms where. 
%Describing the specification in terms of a formal description language gives clarity and reduces the programming errors: 
%(1) Internet application protocols require thorough understanding of long and tedious semi-formal specifications. 
%(2) communication safety. In cases when the communication mismatches and synchronisation of messages is a common source of errors 
%(3) when use cases involve large number of participants and coordination between the participants becomes challenging. Large number of participants. 
 
%Covering a wide variety of patterns which allows comparison of features available in the session-based frameworks being evaluated.
%For the implementation of the usecases in the online
%repository different technologies that integrate
%session types in different programming paradigms were used.

%A taxonomy of domains are presented below with the main
%characteristic that each domain is using technologies from the
%previous domains in the taxonomy. This taxonomy also implies
%a stratification of the application of session types in different
%computation layers.
%%One of the goals of this paper is to present a diversity
%%of application of session types from different domains, as
%%part of our aim to demonstrate the robustness, functionality
%%and adaptability of session types. Here we present the particular
%%communication characteristics for every domain.



%\rumi{For each domain explain (1) What are the challenges when implementing the use cases in that particular domain?
%(2) How Session Types overcome these challenges (currently this is not well explained).}


\myparagraph{Classic Concurrency Problems} Coordination of processes is a challenging problem when implementing concurrent systems.
A study in \cite{ActorCoordinationStudy} points out that "the property of no shared space and asynchronous
communication can make implementing coordination protocols harder and providing a language
for coordinating protocols is needed". The problem is best exemplified when implementing classic concurrency problems.

Classic concurrency problems require correct coordination among multiple components to avoid starvation and deadlock. Preserving the causalities between the interactions is challenging since the communication often involves complex patterns, combining long sequence of interactions with recursive behaviour and nested choice branches.
Often precise message sequence should be followed. Moreover, it is not obvious if the components can be safely composed. Sending the wrong message type, sending to the wrong role or not sending in the correct message sequence may lead to deadlocks, errors which initial cause is hard to be identified or wrong computation results.

%The paper reveals that the coordination of processes is a challenging problem when implementing, and especially when scaling up concurrent systems.

Modelling interactions between components with session types ensures correct synchronisation and prevents deadlocks, unexpected termination and orphan messages.


\myparagraph{Internet Application protocols}
This set of use cases is the first step towards more realistic (real-world) applications. The motivation to apply session types verification techniques to Internet Application Protocols is three-fold.
%: (1) programs should be interropable (2) it may involve untrusted components (3) error-prone specifications.

First, an Internet Application Protocol should conform to a RFC (request for comments specification). Conforming to an RFC specification is error-prone due to (1) the semi-formal nature of the protocol description and (2) the rich interaction structures described (as observed in SMTP and POP3). Scribble is a formal language and is expressive enough to capture the communication patterns required for popular use cases in this domain.  

Second, the aim of the specification is to enable interaction between heterogeneous systems. The Scribble development methodology can be used to verify components implemented in different languages. 

Third, implementations often involve untrusted components. Using session-based runtime monitors both incoming and outgoing messages of a component are verified, thus protecting the implemented components from interactions with untrusted parties. For example, the SMTP client implementation from the repository is implemented in Java but it can interact with any (none session-based) SMTP server implementation.

\ray{...binary (thin abstraction layer over TCP session), can have ``rich'' interaction structure (e.g. SMTP, POP3 conversations), simple data types (ASCII text)...}

%Expresses specific data-structures streaming such as the data-structure of an email,need for translate between RFC text format to/from message/payload types.

%Benefits of ST usage: interoperability, interaction with non-verified components. Motivation for dynamic monitoring,
%as well as static verification. They are low-level protocols and thus inherently binary.


\myparagraph{Web Service Application}
Internet Application Protocols are low level protocols, as such they often specify a protocol between two parties (a client and a server). The aim of the use cases presented in this domain is to demonstrate usages of multi-party protocols. In web services, applications make an extensive use of communications among multiple components and services through a standardised format. Business transactions using web services
%are often termed \textit{business protocols} because each of them
obeys an agreed-upon protocol structure. The protocol stipulates the business logic to be implemented by the application.

To show the applicability of session types to this domain we implemented use cases (Book Store, Travel Agency) designed
by the WS-CDL Working Group \cite{W3C}, intended to represent general concepts common to many applications of web services

This set of use cases is a practical indication that session types can be used to describe the behavioural logic of an application. The current development of the usecases follows a top-down design approach, where the projection of the global protocol is used by different
implementing technologies.

\ray{...multiparty, ``richer'' data types (XML, SOAP, etc), delegation...}
is an interaction scenario designed
by the WS-CDL Working Group [13], intended to represent general concepts
common to many applications of web services

\myparagraph{Network Topologies} Issues with High Performance Computing (HPC) programmers productivity and programs correctness have long been recognised. A survey among MPI (the de facto standard programming model for HPC) programmers \cite{MPIErrors} ranks \textit{communication mismatches} as the most common errors. Communication mismatches include: (1) send/receive inconsistency caused by an error in program execution flow) and (2) send/receive inconsistency caused by incorrect sender and/or receiver specified for a message. These are precisely the type of errors prevented with session types verification. We have implemented multiple parallel algorithms in MPI (Jacobi, Monte Carlo), where the lack of communication errors is guaranteed statically.    

%Parallel algorithms require threads that communicate. Session types can use describe the necessary underlying communication between threads that implement parallel algorithms.
%\rumi{The highlights of this domain are: (1) computation and communication are often separated, (2) topologies are scalable and thus parametrised and (3) topologies are reusable, comprising limited set of patterns.}

%X suggests that the goal of computer science should be making parallel computing productive, efficient, correct, portable, and scalable.
\myparagraph{Parallel Algorithms} In addition to specific parallel algorithms we also evaluate session types on a set of patterns for parallel programming.  The Dwarf benchmark suit \cite{BerkleyPar} is a popular benchmark suit that captures common patterns of communication and computation. %The Seven Dwarfs, constitute equivalence classes where membership in a class is defined by similarity in computation and data movement.
The dwarfs are specified at a high level of abstraction to allow reasoning about their behavior across a broad range of applications.
The previously presented use cases in our repository involved a fixed number of interacting parties. The parallel patterns, however, often involve unknown number of participants. To overcome this problem, we use the protocol description language Pabble. 
% Pattern-based structured parallel programming motivates the need for specifications of flexible topologies.
Pabble is an extension of Scribble with parameterised roles, thus enabling expressing flexible topologies with unknown number of participants.  Pabble can express all structured patterns in the HPC (High Performance Computing) Dwarf benchmark suit. 
%Dwarf suit captures common patterns of communication and computation. %The Seven Dwarfs, constitute equivalence classes where membership in a class is defined by similarity in computation and data movement.
%The dwarfs are specified at a high level of abstraction to allow reasoning about their behavior across a broad range of applications. %Programs that are members of a particular class can be implemented differently and the underlying numerical methods may change over time, but the claim is that the underlying patterns have persisted through generations of changes and will remain important into the future.
%The dwarfs present a method for capturing the common requirements of classes of applications while being reasonably divorced from individual implementations.

Applying session types workflow, in particular generating MPI code form well-established patterns, has shown to improve developers productivity \cite{NCY2015}. It saves development and debugging efforts for MPI parallel applications, especially for novice parallel programmers.

%\myparagraph{Other Domains}
%
%{\em Operating System}.
%	Another domain where session types can be applied to
%	is the description of the communication specifics
%	of operating system algorithms and routines, that
%	co-ordinate the usage of hardware resources.
%
%	\mybf{- Locks: Basic OS structure basic for achieving resource utilisation. Its
%		usage implies race conditions that in turn imply asynchronous
%		and reactive communication. The implementation of locks in the
%		eventful session Java shows that session types can express deadlocks.}
%
%
%{\em Data Structures and Algorithms}.
%	The above layers are using data structures and algorithms.
%	Session types can express the communication
%	concurrent algorithms are using. Furthermore, session types
%	can express the interaction with data structures.
%
%	\mybf{- Collection: A stack client protocol. Used to control the put, get access
%		to a collection structure - when the stack is empty there is not get.
%		Session types describe the logic/properties that a data structure can have.}
%
%	\mybf{- File Access: Similarly used to control the access on a file. Cannot
%		read from a file if the file is not open first and if the file is empty.
%		The protocols ends by closing the file. Again access to resources
%		can be described using session types.}
%{\em Hardware}.
%	Hardware mechanisms complete the stratification of domains.
%	The communication of hardware modules may also be expressed
%	using session types.
%
%	\mybf{- Memory Coherency: Hardware components communicate, here we have two memories
%		that need to be consistent with each other on a hardware level. Session types can
%		describe the hardware (signals/messages) interaction between hardware components.}
%
%{\em Security}.
%	Session types can also find applications in the security domain,
%	which is a domain that supports all other domains in the above list.
%
%	\mybf{- There are some security protocols in the SILL repository. We need to
%			be careful in the description because it is a reference to other people.}



\subsection{``Use-Case highlights''}

\paragraph{Book-Store}

The book-store is a canonical example for demonstrating 
session types. Its global and \BuyerOne local protocol
can be found in~\figref{scribble_bookstore}. Two
Buyer roles, \BuyerOne and \BuyerTwo, interact with a \Seller
role to buy a book. \BuyerOne request a quote for a book.
The \Seller replies with a price and then \BuyerOne asks
\BuyerTwo for a contribution. \BuyerTwo then makes a choice:
i) \BuyerTwo can agree to contribute and informs both \BuyerOne
and the \Seller, with the price transferring interactions taking
place; ii) \BuyerTwo does not agree and ends the interaction
informing both \BuyerOne and \Seller.

The Book-store protocol reveals a logic interaction between participants.

It is implemented in Mungo using the automatic code generation of
StMungo. The effort of the programmer was focused on filling the
decision logic for the values exchanged on the message interactions.

\mybf{put more}

\paragraph{SMTP}

\mybf{put SMTP here}

\paragraph{HTTP.}

Despite, the fact that HTTP is a basic request-response protocol,
its global specification can be defined in many different ways:
e.g.~a request/response pattern with large message types. The approach
taken here is to construct a request (resp., response) header as
a stream of simpler messages passed that construct the overall
request (resp., response) header. 

\paragraph{Travel Agency.}



...W3C CDL working group Web services use case, initially specified as binary sessions between multiparty roles (not a single multiparty session), features delegation...


\paragraph{Parallel algorithms.}

...shared memory as transport, integrating linearity for session typing into language as general linearity/aliasing control for shared memory message passing optimisation...


\paragraph{..OOI python use cass...}

...TODO: add use cases? (e.g., negotiation, resource access control)... ...python: run-time monitoring motivation...


\paragraph{Collection Data-Structure and File Access}

These two use-cases demonstrate the interaction
of a stack (resp., file) client with a distributed
stack data-structure (resp., file),
where the client needs to check whether the stack (resp., file)
is empty before acquiring an element.
In the case of the stack, pushing an element in the
stack is always possible.
This use-case demonstrates that interaction with
distributed data-structures can be refined,
structured, and ultimately controlled
using session types.

\paragraph{Concurrent Fibonacci}

Concurrent Fibonacci is an example that shows the
underlying communication pattern needed by an
a parallel algorithm. The algorithm assumes
two nodes that store consecutive Fibonacci
numbers. An exchange in numbers allows for
the calculation of the next Fibonacci number.

In contrast with network topologies this algorithm
is defined on a fixed number of nodes and ensures
no errors in the communication process of the parallel
algorithm.


\paragraph{others?}

...

