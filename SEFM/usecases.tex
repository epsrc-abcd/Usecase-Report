\section{Usecases}
\label{sec:usecases}

This section will give a summary of the usecases in
the ABCD online repository~\cite{usecase_repository}. At the
same time it will give a more detail presentation on
how session types are used in the implementation of the network application
usecase for a book-store, which is a standard example for introducing
session types. It will also focus on the implementation of a session type
Simple Mail Transfer Protocol, which is a standard network protocol.

\input{figures/fig-usecases}

Table ~\figref{usecases} summarizes the use case from the ABCD repository. 
The table presents the name of the use case, its original source, and the language that it is implemented. Full source code, 
running examples and and detailed description of all use cases can be found in \cite{OnlineRepo}. 
The use cases are organised into domains  and for each domain we have chosen representative examples.  

\subsection{Domain Classification of Usecases}

The usecases are presented following a wide range of
application domains, in order to demonstrate the fact that
session types can capture
a broad area of communication specifications. 
For the implementation of the usecases in the online
repository different technologies that integrate
session types in different programming paradigms were used.

%A taxonomy of domains are presented below with the main
%characteristic that each domain is using technologies from the
%previous domains in the taxonomy. This taxonomy also implies
%a stratification of the application of session types in different
%computation layers.
%%One of the goals of this paper is to present a diversity
%%of application of session types from different domains, as
%%part of our aim to demonstrate the robustness, functionality
%%and adaptability of session types. Here we present the particular
%%communication characteristics for every domain.

\begin{enumerate}
	\item	{\em Network Application/Business Logic}.
			The first two applications in \figref{usecases}
			come from the domain of network applications.

			The first network application is the online book-store,
			where its protocol and specifics are already discussed
			in the paper. It is a standard usecase able to demonstrate
			the basic practical features of session types.

			The Book-store usecase is implemented following a
			communication protocol that embeds an execution logic
			for the application. This is a practical indication
			that session types can be used to describe the
			behavioural logic of an application.
			The current development the usecase follows a
			top-down design approach, where the projection
			of the global protocol is used by different
			implementing technologies.
			The book-store is implemented in Session Java and Mungo.
			\dk{need LINKS and the hybrid implementation}

			\mybf{- Book-store: Standard example, Communication Interaction shows business logic}

			\mybf{- Chat-Server: Implement a server/client architecture, design an application protocol for the servers,
				client implementations should conform to the protocol, Erlang monitoring implementation cite S. Fowler's Master Thesis.}
		

%			is implemented in different technologies

%	Session types can be used to develop protocols for applications
%	that run inside a network.
%	A protocol given in a session type structure, apart from the
%	specification of the communication of the application, will
%	reveal a kind of business logic for the application.
	
	\item	{\em Network Protocols}.
	Session types can be used to describe standard and non-standard network protocols.
	Typically a standard network protocol should conform to
	an informal RFC (request for comments specification. Session types
	can present a network protocol formally its manipulation easier
	by both engineers and machines.
	Non-standard network protocols can also be developed.

	\mybf{- HTTP: Request response standard RFC protocol, stateless,
			assume different types for each request/response header (not just a text header)
			request-response sequences can give a further structure
			of interaction, it would be nice if we have a client to stream tree-structured data.
			automatically generated API from the Scribble tool-chain} 

	\mybf{- SMTP: Stateful standard RFC protocol. Expresses request/respond, 
				Expresses specific data-structures streaming such as the data-structure
				of an email,
				need for translate between RFC text format to/from message/payload types
				Complex state makes implementation difficult - session types
				remove a burden from the developer because they automatically
				verify that the state of the code follows the state of the protocol. }
	
	
	\item	{\em Systems/Applications}.
	A session type may be used to describe the communication
	specifics of an application that uses multiple resources
	inside a computing machine.

	\mybf{- Do we have a system to describe }
	
	\item	{\em Operating System}.
	Another domain where session types can be applied to
	is the description of the communication specifics
	of operating system algorithms and routines, that
	co-ordinate the usage of hardware resources.

	\mybf{- Locks: Basic OS structure basic for achieving resource utilisation. Its
		usage implies race conditions that in turn imply asynchronous
		and reactive communication. The implementation of locks in the
		eventful session Java shows that session types can express deadlocks.}

	\mybf{- Concurrency Algorithms: Classic concurrency problems expressed in Session types.
		Implementing in the python monitored actors framework. }
	
	\item	{\em Data Structures and Algorithms}.
	The above layers are using data structures and algorithms.
	Session types can express the communication
	concurrent algorithms are using. Furthermore, session types
	can express the interaction with data structures.

	\mybf{- Collection: A stack client protocol. Used to control the put, get access
		to a collection structure - when the stack is empty there is not get.
		Session types describe the logic/properties that a data structure can have.}

	\mybf{- File Access: Similarly used to control the access on a file. Cannot
		read from a file if the file is not open first and if the file is empty.
		The protocols ends by closing the file. Again access to resources
		can be described using session types.}

	\mybf{- Concurrent Fibonacci: Parallel algorithms require threads that communicate. Session
		types can use describe the necessary underlying communication between threads that implement
		parallel algorithms.}

	\mybf{- Network Topologies: Topologies are scalable and thus parametrised. Pabble is
		an extension to Scribble that allows us to describe and cope with parametrised protocols.}


	\item	{\em Hardware}.
	Hardware mechanisms complete the stratification of domains.
	The communication of hardware modules may also be expressed
	using session types.

	\mybf{- Memory Coherency: Hardware components communicate, here we have two memories
		that need to be consistent with each other on a hardware level. Session types can
		describe the hardware (signals/messages) interaction between hardware components.}

	\item	\mybf{\em Security}.
	Session types can also find applications in the security domain,
	which is a domain that supports all other domains in the above list.

	\mybf{- There are some security protocols in the SILL repository. We need to
			be careful in the description because it is a reference to other people.}
\end{enumerate}

\begin{comment}
Sleeping barber: The use case presents another classic synchorisation problem. A barber is waiting for customers to cut their hair. When there are no customers the barber sleeps. When a customer arrives, he wakes the barber or sits in one of the waiting chairs in the waiting room. If all chairs are occupied, the customer leaves. Customers repeatedly visit the barber shop until they get a haircut. The key element of the solution is to make sure that whenever a customer or a barber checks the state of the waiting room, they always see a valid state. The problem is implemented using a Selector actor that decides which is the next customer, Customer actors, a Barber actor and a Room actor. Note that, differently from the previous use cases, the protocol between the Customers and the other actors is multiparty (not binary). To guarantee a valid synchronisation, precise message sequence should be followed. While the use cases so far demonstrated succinct recursion and request-reply patterns, interleaved together, this one demonstrates a communication structure with long sequence of interactions, where preserving the causalities is the key to achieving deadlock free communication. The use of session types prevents potential deadlock, unexpected termination and orphan messages. 
\end{comment}

\subsection{Lessons Learned}