\section{Session types and Software Engineering}
\label{sec:session_engineeering}


\mybf{Write here about the main parts of software life-cycle (requirements, specification, design, implementation, verification, testing, maintenance), and software management and organisation.

Support the text later with the discussion of section 2 and the results of Section 3.}

The use-cases presented in \secref{usecases} exhibit a diversity
in domains, paradigms and technologies.
Despite this diversity, there are common elements on how software
is engineered using session types.

Firstly, a session protocol can be seen as a way for specifying
communication {\em requirements}. For example, in the case of web service applications
the global protocol describes a logic of interaction between participant,
whereas in internet protocol the session specification gives
an intuition for understanding the overall protocol. 
Protocols can also be expressed using diagrammatic languages,
that can be used to communicate a system specifications.
For example, the state machine for the SMTP client local protoco (\mybf{see appendix}).
%Global protocols can be expressed as
%petri-nets~\cite{DBLP:conf/tgc/FossatiHY14}, communicating
%finite state machines~\cite{Denielou:2012:MST:2259248.2259258}
%and BPMN choreographies~\cite{LTY2015}.

Secondly, a global protocol may drive the {\em design} and
{\em implementation} of a software.
Automated code generation in the case of SMTP and HTTP
gives code with a specific design.
Also type-checking is used in many occasions to ensure
software with no communication errors.

Thirdly, whenever session fidelity is ensured, either
using type-checking, code generation, or even the
inference/synthesis approach (\dk{there is inference/synthesis usecase})
it is ensured that the communication properties of the
software are {\em validated}.

Finally, runtime monitoring is not only used to ensure
correct communication at runtime. Monitoring can also
be used to {\em test} whether an implementation
is correct or not.
This is the case for concurrency problems, DNS and
chat application use-cases.

Overall, session types can drive the software development
process due to their formal and structured nature.
The main effort in developing of the use-cases for the repository
was focused in the development of the session protocol.
Given that a protocol captures the desirable software requirements
then code development needs less effort and resources.
 
As a formal method session types belong to the class of type systems,
which are a static analysis technique applied directly
on the source code in order to verify a set of predefined properties.
In the case of session types these properties derive
from the fundamentals of {\em good} communication.
Also, types are subject to a syntax,
and possibly a semantics, that describes an implementation structure.
%%These two facts allow for the integration of session types both in-depth
%%and in-breadth in the software development process.
Consequently, session types can provide automated support throughout
the entire process of software development. 



%In any of the above methodologies, session types can be used as
%requirements  to drive the software development process.
%In the top-down approach, local types can be used to give intuition
%and guide developers when implementing code.
%In the bottom-up approach, more agile development teams
%can analyse and compare the obtained global and/or local protocols
%against the intended communication behaviour using human
%reasoning techniques. Protocols can also be expressed
%as diagram. For example, a local protocol is a syntactic form
%of a state machine. Global protocols can be expressed as
%petri-nets~\cite{DBLP:conf/tgc/FossatiHY14}, communicating
%finite state machines~\cite{Denielou:2012:MST:2259248.2259258}
%and BPMN choreographies~\cite{LTY2015}.



\mybf{Hint how session types can be used in the software life-cycle. e.g.
	in a top-down approach:
	specify communication requirements and build prototypes,
	use session types to describe software structure,
	type-checker/code generators/monitors can be used in implementation.
	bottom-up approach:
	design structures,
	infer specification,
	synthesis as a verification technique, etc...
	}

In contrast other formal methods, have restricted applications
in specific software development phases.
For example, model checking
narrows down to verification/testing phase of software development.
It requires specific expertise, to define
of a complete model that approximates software and furthermore,
perform semantic analysis based on non-predefined properties.
Often in the case of error detection, results are hard to analyse
and developers need to re-iterate through previous phases
to fix errors.
Another example is the usage of formal specification languages
that do not find any usage after the specification phase.


%\begin{itemize}
%	\item	Session types protocols. Structures that describe
%			a behaviour on the communication interface.
%
%	\item	Top down design: The global type to local types via projection procedure as
%			\begin{itemize}
%				\item	a way for engineers to design
%				\item	a way to co-ordinate software developers.
%			\end{itemize}
%
%	\item	Bottom up design: The inference/synthesis procedure as
%			a way for more agile independent teams to co-ordinate and
%			exchange the behaviour of interfaces as session type
%			specifications.
%
%	\item	Testing: Session typed modules can be used to test
%			a software in the development phase.
%
%	\item	Reverse engineering: inference/synthesis
%
%	\item	The relation of session types with diagrammatic languages
%			\begin{itemize}
%				\item	BPMN \cite{citation_needed}
%				\item	global graphs\cite{citation_needed}
%				\item	petri nets\cite{citation_needed}
%				\item	state machines \cite{citation_needed}
%			\end{itemize}
%\end{itemize}


\subsection{...lessons learned...}

\paragraph{``technical''}

\begin{itemize}
\item
types features: parallel (``race conditions''), interruptible, ...more

\item
type system and endpoint language features: event-driven sessions, CPS actors (Akka/Scala), ...more

\item
runtime: transport-independent sessions, ST-cFSM correspondence from monitoring, implementing asynchronous distributed delegation, ...more
\end{itemize}


\paragraph{``engineering''}

...

