% !TeX root = main.tex

\section{Analysis of the Use-Case Repository}
\label{sec:session_engineeering}

We now discuss the experience gained from our work on the use-case repository, the possibilities for session types in software engineering, and directions for future research.

%This section does an overall discussion on the
%results, experience gained and possible future work
%derived from the application
%of session types for the implementation of the
%repository presented in \secref{usecases}.
%The discussion focuses on the technical lessons
%learned, as well as an informal discussion
%on the engineering perspective of the software
%developed.

%subsection{Technical Lessons Learned}

We have demonstrated that session types are applicable to a range of use-cases in a range of application domains. All of the scenarios in the repository are structured around message-passing, choice, and recursion, which are well-supported by session-typed languages and tools. However, there are communication patterns in concurrent software that have not yet been addressed by session types. Examples are the interaction of a role with two other roles in parallel, or situations in which a signal can interrupt the communication between two roles. Further research will extend the scope of session types in these directions. 

%Session types exhibit robustness in a wide range of
%use-cases and domains. All the demonstrated scenarios
%are structured on the message passing,
%choice interactions and recursion. 
%However, there are communication patterns 
%in concurrent software that remain open
%questions, such as the interaction of a role with two
%other roles in parallel, or the case where a signal
%can interrupt the communication between two roles.

The use-case repository contains examples of session types in a range of programming paradigms: imperative, object-oriented, functional, and actor-based. It also shows the use of session types with the MPI framework. Further research and development will extend implementations to cover more points in the language/paradigm space; for example, one current project is targeting the Akka framework in Scala.

%Session types can also be embedded in different
%programming paradigms. The use-cases in this paper
%use imperative, object-oriented, functional, and
%actors programming.
%In addition, there are use-cases
%using session types on the MPI.
%Future work involves embedding session types
%in different paradigms, e.g.~continuation passing
%style actor, like Scala.

Several implementation technologies have been applied to the use-cases in the repository. However, there is still a need for more implementation work in order to realise all of the capabilities of session types as practical tools. In particular, the bottom-up techniques of type inference and synthesis (the red arrows in \figref{diagram}) have not yet been implemented to the same extent as the top-down techniques.

%There are numerous technologies used to developed use-cases
%in the repository. However, there is still need to continue
%developing technologies to fully utilise the capabilities
%of session types.
%For example, the use-case repository lacks a
%scenario developed using the bottom up technique
%presented in \figref{diagram}, due to
%the current lack of technologies.
%Nevertheless, this work
%is a strong indicator to drive similar research towards
%that direction as well.


%\begin{itemize}
%	\item
%	types features: parallel (``race conditions''), interruptible, ...more
%	
%	\item
%	type system and endpoint language features: event-driven sessions, CPS actors
%	(Akka/Scala), ...more
%	
%	\item
%	runtime: transport-independent sessions, ST-cFSM correspondence
%	from monitoring, implementing asynchronous distributed delegation, ...more
%\end{itemize}

%\mybf{Write here about the main parts of software life-cycle 
%(requirements, specification, design, implementation, verification, 
%testing, maintenance), and software management and organisation.

%Support the text later with the discussion of section 2 and the results of 
%Section 3.}

\myparagraph{Session Types in Software Engineering}
As already discussed in \secref{sessions_integrate},
due to their formal and structured nature,
session types can provide support throughout the
entire process of software development.
The results in \secref{usecases} provide evidence for this claim.
%come to support
%the ability of session types in offering solutions
%to software development.
%
Despite the diversity of domains, paradigms,
and technologies, the use-cases exemplify common engineering patterns.
%can be found in the software developed in \secref{usecases}.

A first observation is the use of session protocols
as a way of understanding software communication
{\em requirements}. For example, the bookstore
session protocol (\figref{scribble_bs}) can give
the reader a clear understanding of the interaction logic of
the problem. Furthermore, the fact that session protocols
can be expressed in diagrammatic languages, helps
the process of transferring requirements into software,
e.g.~the SMTP client state machine in \appref{state_machine}.

A second observation is that the main effort for each use-case
is focused on the development of a protocol.
Session specifications need to capture the exact
and valid communication {\em requirements} of a system.
For example, the SMTP global protocol (\appref{smtp_global}) %(resp., HTTP)
needed a significant time investment in the study of RFC 5321. %(resp., RFC 2616).
During the development process the Scribble validating tool
helped the programmer develop a valid protocol for SMTP.

Thirdly, a session protocol can be seen as an approximation
of the software under development that can be used to drive
and lessen the burden for the {\em design} and {\em implementation} process.
For example, the automated code generation in the case of
SMTP and HTTP decreased the development time. Furthermore,
automatic type-checkers removed the burden of further
{\em validating} the software.

Finally, monitoring is not used only for ensuring
correct runtime communication.
It can also be used to {\em test} the communication
against test cases that resemble arbitrary software clients.
This approach was used in the development of the DNS and
Chat use-cases. Errors in the monitoring phase
lead to an iteration for redevelopment of the session protocol.

The above discussion lacks metrics
for an accurate understanding of the cost and effectiveness
of the application of session types in software engineering.
The only set of use-cases that have such support is network
topologies~\cite{NCY2015}. 
A valuable new area of research in session types would
be to quantify their effectiveness for software development,
in terms of bugs, lines of code, performance, development time and cost.

%Finally, session types have the ability to capture the
%communication specifics of a system as whole through the
%global protocol, and at the same time provide a local
%understanding for the system as a set of interacting
%entities. 


%Overall, session types can drive the software development
%process due to their formal and structured nature.
%The main effort in developing of the use-cases for the repository
%was focused in the development of the session protocol.
%Given that a protocol captures the desirable software requirements
%then code development needs less effort and resources.


%As a formal method session types belong to the class of type systems,
%which are a analysis technique applied directly
%on the software code in order to verify a set of predefined properties.
%In the case of session types these properties derive
%from the fundamentals of {\em good} communication.
%Also, types are subject to a syntax,
%and possibly a semantics, that describes an implementation structure.
%%These two facts allow for the integration of session types both in-depth
%%and in-breadth in the software development process.
%Consequently, session types can provide automated support throughout
%the entire process of software development. 

%This last claim can be supported by the experience gained
%in developing the use-cases in \secref{usecases}.


%In any of the above methodologies, session types can be used as
%requirements  to drive the software development process.
%In the top-down approach, local types can be used to give intuition
%and guide developers when implementing code.
%In the bottom-up approach, more agile development teams
%can analyse and compare the obtained global and/or local protocols
%against the intended communication behaviour using human
%reasoning techniques. Protocols can also be expressed
%as diagram. For example, a local protocol is a syntactic form
%of a state machine. Global protocols can be expressed as
%petri-nets~\cite{DBLP:conf/tgc/FossatiHY14}, communicating
%finite state machines~\cite{Denielou:2012:MST:2259248.2259258}
%and BPMN choreographies~\cite{LTY2015}.



%\mybf{Hint how session types can be used in the software life-cycle. e.g.
%	in a top-down approach:
%	specify communication requirements and build prototypes,
%	use session types to describe software structure,
%	type-checker/code generators/monitors can be used in implementation.
%	bottom-up approach:
%	design structures,
%	infer specification,
%	synthesis as a verification technique, etc...
%	}

%\mybf{In contrast other formal methods, have restricted applications
%in specific software development phases.
%For example, model checking
%narrows down to verification/testing phase of software development.
%It requires specific expertise, to define
%of a complete model that approximates software and furthermore,
%perform semantic analysis based on non-predefined properties.
%Often in the case of error detection, results are hard to analyse
%and developers need to re-iterate through previous phases
%to fix errors.
%Another example is the usage of formal specification languages
%that do not find any usage after the specification phase.}


%\begin{itemize}
%	\item	Session types protocols. Structures that describe
%			a behaviour on the communication interface.
%
%	\item	Top down design: The global type to local types via projection procedure as
%			\begin{itemize}
%				\item	a way for engineers to design
%				\item	a way to co-ordinate software developers.
%			\end{itemize}
%
%	\item	Bottom up design: The inference/synthesis procedure as
%			a way for more agile independent teams to co-ordinate and
%			exchange the behaviour of interfaces as session type
%			specifications.
%
%	\item	Testing: Session typed modules can be used to test
%			a software in the development phase.
%
%	\item	Reverse engineering: inference/synthesis
%
%	\item	The relation of session types with diagrammatic languages
%			\begin{itemize}
%				\item	BPMN \cite{citation_needed}
%				\item	global graphs\cite{citation_needed}
%				\item	petri nets\cite{citation_needed}
%				\item	state machines \cite{citation_needed}
%			\end{itemize}
%\end{itemize}

