\section{Session Types}
%\label{sec:preliminaries}
\label{sec:session_types}


The section introduces session types through a
a discussion about the need of session types in
software engineering.
It also presents the Scribble~\cite{scribble} protocol
description language which is a formal language for describing
protocols using session type principles.
The overall discussion in this section identifies and sets
a clear and distinctive terminology needed to
for transferring to a wider audience the basic ideas of session
types.

\subsection{Session Types and Software Engineering}%: Notions and Terminology}
\label{sec:sessions_software}

\input{figures/fig-sequence_diagram}

Communication \emph{protocols} in software engineering
are usually described and communicated among humans
by using the most intuitive graphical form of sequence charts
(see \figref{seqchart}).
Sequence charts are used to depict communication flow as ordered
sequence of communication \emph{message passing} among communication
participants that represent particular \emph{roles} in communication
protocol.

In \figref{seqchart}, the case of the Bookstore protocol, which is a usecase
in the ABCD online repository~\cite{usecase_repository},  is presented.
The Bookstore protocol specifies an interaction between two online Buyer roles
that invoke a process of buying a book from an online Seller role, while
sharing the expenses.
In the sequence chart, each role is represented with vertical line and
communication messages are represented with horizontal directed arrows
indicating the direction of communication flow.
Intuitively, the communication progress is proceeds downwards.
Thus, visually the protocol behaviour is represented within the chart.
However, sequence charts are not considered as formal tools because
such described protocols can not be verified as being complete or unambiguous.

For example, in industrial practice, the communication protocols for
distributed software, are usually described in natural language and
discussed with help of the sequence charts.
%After that and with the help of sequence charts,
%the protocols are implemented between the communication components
%of the software.
%within the distributed software
%with specified communication protocol.
With the help of sequence charts,
each software module that participates in the
protocol communication implements
its \emph{local} software role within the protocol.
Usually the process of implementing the local implementation
impose numerous possible solutions that are often hidden and
omitted from sequence chart.
\dk{what is hidden? - overall structure of the protocol, logic on choices}
Another limitation of sequence charts, is the inability to deal with complex
communication protocols where complex communication interactions
that involve multiple parties become hard to follow and reason.

A solution to manage communication complexity
is the introduction of \emph{structure} within the communication protocol.
Session types describes communication in a structured and rigorous fashion,
and is aiming to define concepts for structured communication
that should enable better mastering of communication complexity.

%describing communication protocols

%Session types can be seen as types that describe behaviour.
Typically, a type is broadly understood
as a meta-information concept, that is used describe a class of a data.
Structures of types are used to describe data structures.
When types are structured as input/output requirements they
are used to describe functionality.
The combination of functionality and data structures give rise
to the \emph{object oriented} concepts of classes and interfaces.% of objects.
%
A session type extends %the above approaches of
the notion of a type to capture the communication behaviour in concurrent systems.
% definition of session types
{\em A session type is a type structure that describes a communication
	behaviour in terms of a series of send and receive %message passing
	interactions between a set of communicating entities and it is used
	to characterise data structures that are used to implement communication.}

\subsection{Sessions as Protocols: The Scribble Protocol Description Language}
\label{sec:sessions_scribble}

The Scribble tool-chain~\cite{scribble} is a tool that indents
to serve as a core element in the process of integrating
the practical aspects of session types in the software
design and development process. The basic module of the Scribble
tool-chain is the Scribble protocol description language,
which is a syntax that expresses session type specifications.
The design of the Scribble language draws directly from
the principles of session types. For the sake of example
consider part of the session type protocol for the Book-store
usecase as in \figref{scribble_bs}. 
This section defines
the main terminology for session types and at the same
time clarifies the notions through the presentation
of the Scribble language.

Practically, a session type can be seen as a formal
{\em specification} of a communication {\em protocol} among communicating {\em roles}.
The syntax for session types is defined on pairs of operations:
(i) the {\em send} and {\em receive} operation give rise to
the {\em message passing} interaction; and
(ii) the {\em select} and {\em branch} operators enable the
{\em choice} interaction.

Message passing is used for sending data from one role the another.
The data that are passed are described in terms of their type. Session
types can also support the case of {\em session delegation}
where a session type value, i.e.~a structure that implements communication,
is passed as a message.
Choice requires for a role to use a value called {\em label}
to select a communication behaviour among
a set of behaviours, called {\em branch}, offered by another role.
The choice interaction enables formal specifications that can
cover a more complex structure of communication and among all possible
cases that may happen, in contrast to the limiting structure of
a sequence diagram.
%The syntax for session types is defined on {\em send} and {\em receive},
%and {\em select} and {\em branch} operators.
%Sending and receiving data gives rise to the notion of {\em message passing}.
%In a session type messages are described via their types.
%The case where a session typed value is passed as a message is called {\em session delegation}.
%The interaction of select and branch defines the {\em choice} interaction.
%Choice requires for a role to use a value called {\em label}
%to select a communication behaviour out of a set of behaviours, called {\em branch},
%offered by another role.
%\textbf{Important is to note that branch and choice elements within the formal specification force
%the user to think among all possible cases that may happen within an session type.
%Comparing to sequence charts which are not formal and thus more error prone.}

Session types assume a {\em global} protocol that describes the
communication interaction of all the roles inside a concurrent system.
A global type enables a view of a system as a whole, instead of the 
approach that a concurrent system is a set of communicating modules.
The perspective of a global protocol through a single role
is called {\em local} protocol. The local protocol describes
the communication interaction of a single role with all other roles
in the system.

The relation between a global protocol and the
local protocols of its roles, is expressed
through the {\em projection} procedure;
% called {\em projection}.
%Projection to a role
%is a procedure that can be done
%can be done automatically;
given the global protocol and a role, projection
returns as a local protocol only the
interactions of the global protocol that are concerned with
the role.

The reverse procedure from projection is called {\em synthesis},
where a set of local protocols are composed together in a global
protocol.


\input{figures/fig-scribble_bookstore}

Line 1 of the upper protocol in \figref{scribble_bs} shows the
Scribble definition of the global protocol for the Book-store usecase.
The communication takes place
among roles the \BuyerOne, \BuyerTwo and \Seller. Line 2 demonstrates
the syntax of a message passing interaction; a message
of type \code{title} labelled with label \code{book} is send \lstinline|from|
role \BuyerOne \lstinline|to| role \Seller. In Scribble messages are
defined as a list of types annotated with a label.

In line 5 of the protocol their the usage of a choice interaction,
where role \BuyerTwo makes an internal decision and selects
out a two possible outcomes, that are
expressed with the labels \code{agree} in line 5 or \code{quit} in line 6.
In  both cases roles \BuyerOne and \Seller respectively offer
alternative branches. The choice interaction requires that
Role \BuyerTwo informs roles \BuyerOne and role \Seller. All
three roles will then synchronise on the same choice.

\dk{describe the recursion construct?}

Line 1 of the bottom protocol defines the local protocol 
for \BuyerOne of the Book-store protocol. Role \BuyerOne
interacts with roles \BuyerTwo and \Seller. In essence,
the local protocol for role \BuyerOne is derived automatically
by stripping out all the irrelevant information with respect
to \BuyerOne from the global protocol.

\subsection{Integrating Session Types in Software Development: The Scribble Tool-chain}
\label{sec:sessions_integrate}

Apart from a protocol description language,
Scribble offers a tool-chain that 
integrates session types in the software
development process.

\input{figures/fig-sessions_software}

%Below the term system is used to describe the whole concurrent
%system and the term \dk{program} is used for communication module
%inside the system. \textbf{Bellow the term system is used to describe whole local protocol
%implementation as a set of communication modules it is composed of? }

\figref{diagram} clarifies the terminology
developed previously by showing the typical
\mybf{usage} of session types in the software
design and development. Furthermore, it distinguishes
the desirable properties that are offered by 
session types.

In \figref{diagram} circles
represent source code for either the software
under development or for the definition
of the session type protocols. The arrows
represent automated procedures that ensure
the desirable properties of session types
in the development process. The Scribble
tool-chain supports many of these automated
procedures.
An important assumption
is that the software source code in the bottom
of \figref{diagram} is developed using 
a programming language that
makes use of a communication interface
that can be automatically identified.

In a typical top-down approach, a developer will first develop a global protocol
and express it syntactic form. This for example can be done
using the Scribble protocol description language.
The global protocol source code is shown
on the top of \figref{diagram}.
The next step is to run a procedure to verify the 
global protocol correctness \dk{what does it verify?}.
After the global protocol verification, a projection
procedure takes place where a local protocol
for each global protocol role is derived.
Verification and projection are supported by the Scribble tool-chain.

One way to use the set of local protocols is to ensure
conformance between the source code of the
software under development and the local protocols,
by using a type-checker procedure.
%To achieve this there is the assumption that
%the programming language used to develop the
%software source code, makes use of a communication
%interface that can be identified by a type-checker
%procedure.
The type-checker takes as an input a software
module, identifies its communication operations,
and derives the communication behaviour of
the module. 
The type-checker also takes as an input the
corresponding local protocol and checks
whether the software module
implements the corresponding role communication.
Upon success, the result is verified software that
enjoys the session types {\em safety} and {\em progress}
properties.

Another way of using the set of local protocol is
for monitoring the execution of a concurrent set
of communicating software modules. The local protocols
are used to feed a set of local monitors. Essentially,
the local monitors run a state machine that is derived
out of the local protocol syntax. The monitor
platform also requires for the concurrent software
execution. The assumption to be made here is that
monitor platform implements the communication interface
on top of the monitoring interface.
Scribble does support the procedure of deriving
state machines out of local protocol syntax.

In \figref{diagram} there is the bottom-up approach as well,
were the communicating modules of a concurrent software
are developed independently. Then an inference 
procedure identifies the communication behaviour
of each module that results in a set of local
protocols. Then the synthesis procedure takes place
where the derived local protocols are synthesised
to create a global protocol. Upon success, the
developed software is guaranteed to ensure
the desirable session type properties.

%Typically, a protocol is first expressed globally and then
%projected locally \textbf{on each protocol role, projecting one local protocol specification per each protocol role.}
%Local specifications are then implemented by the corresponding
%\mybf{programs}.
%The term {\em session fidelity} is used to express
%the conformance of a \mybf{program}, to the local protocol of the
%corresponding role. Session fidelity can be checked mechanically,
%through techniques like type-checking and monitoring.

The case where the local protocols of all the roles in a global protocol
are implemented by the corresponding communicating modules of
a system is called session fidelity. When session fidelity is
ensured
then a number of communication properties can be guaranteed
for the concurrent software:
%
\begin{enumerate}[label=$\bullet$]
	\item	Every execution state of the system has {\em safe} communication behaviour:
	%	
	\begin{itemize}
		\item	{\em Communication operator matching}: Every send (resp., select) operation has a corresponding receive (resp., branch) operation.
		\item	{\em Message type matching}: The type of every message being send matches the type of the message expected to be receive.
		\item	{\em Deadlock-freedom}: Consequently, every message send will be eventually received.
	\end{itemize}
	
	\item	Every state of the protocol will {\em progress} to a safe state.
\end{enumerate}

As seen in \figref{diagram} Scribble and the procedures
that manipulate session type protocols lie at the core
of the software development process. This is also clarified
by the experience in developing the usecases for the ABCD
online repository. The Scribble platform and its procedures
has an independent status next to the plethora of technologies and
programming paradigms used in the case studies.

%\subsection{Session Types as Protocols: The Scribble Tool-chain}
%
%This section presents the Scribble~\cite{scribble} tool-chain
%as the core tool for the application of session types.
%This section also uses Scribble to clarify the terminology
%developed in the previous section.

%The basic module of the Scribble tool-chain is the
%Scribble protocol description language,
%which is a syntax that expresses session type specifications.
%The design of the Scribble language draws directly from
%the principles of session types.

%\input{figures/fig-scribble_global_bookstore}

%In \figref{scribble_bs}, uses the Scribble protocol for the
%Bookstore usecase in the online repository~\cite{usecase_repository},
%to present the Scribble syntax.
%Line 1 defines the 
%of global protocol \lstinline|Bookstore| between
%roles \lstinline|Buyer1|, \lstinline|Buyer2| and \lstinline|Seller|.
%%The communication structure is expressed 
%%as a sequence of {\em endpoint} to endpoint message passing
%%interactions between the roles of the protocol.
%%Messages are described in terms of a message type,
%%where  a label is used to annotate a list
%%of types.
%Line 2 gives an example of the simplest endpoint-to-endpoint
%message passing interaction,
%where a message with
%label \lstinline|book| and type \lstinline|title| (notation \lstinline|book(title)|)
%is send from (keyword \lstinline|from|) role \lstinline|Buyer1| to (keyword \lstinline|to|)
%role \lstinline{Seller}.
%In Scribble messages are described as a type structure
%consisted of a label and a list of message types.


%Line 5 of the protocol clarifies the choice interaction, where
%role \lstinline|Buyer2| selects a choice from two possible outcomes,
%expressed with the labels \lstinline|agree| or \lstinline|quit|. In 
%both cases roles \lstinline|Buyer1| and \lstinline|Seller| offer
%alternative branches.


%\input{figures/fig-scribble_local_bookstore}

%We use the term {\em local} protocol to describe
%the communication structure at the level of a single participant.
%As session types is a type discipline with the requirement to
%be enforced on a program, we may sometimes refer to a session type
%protocol as communication {\em specification}.

%For example Scribble code:
%%
%\begin{lstlisting}
%  msg(int) from A to B;
%\end{lstlisting}
%%
%describes the global protocol between role \lstinline|A| and \lstinline|B|,
%where participant \lstinline|A| sends message of type \lstinline|msg(int)|
%to participant \lstinline|B|. From the local perspective of participant
%\lstinline|A| the protocol would be:
%%
%\begin{lstlisting}
%  msg(int) to B;
%\end{lstlisting}
%%
%where it describes the sending of message \lstinline|msg(int)|
%to participant \lstinline|B|.


\subsection{Usecase Classification on Technologies used}
\dk{Just presentation and references}

The technologies used to implement the demonstrated usecases are presented
below:
%
\begin{enumerate}
	\item	Session Java~\cite{HU07TYPE-SAFE} is the first tool
			developed as a tool with a library that support binary session
			types. The tool requires compiler support to perform session
			type-check.

	\item	The Eventful Session Java~\cite{event} is an extension
			of session types to support asynchronous, event-driven programming.

	\item	Multiparty Session C~\cite{NYH12}
			is the first tool that implemented a
			multiparty session type library for MPI.
			The tool requires compiler support to perform session
			type-check.


	\item	Session fidelity can also be ensured using runtime monitoring.
			Modules for monitoring were implemented in python and are presented in~\cite{DBLP:conf/rv/NeykovaYH13}.

	\item	Session types are embedded in the Actors paradigm in the following technologies:
			\begin{itemize}
				\item	An implementation that uses the python monitoring module for session types to
						monitor python threads that simulate actors~\cite{DBLP:conf/coordination/NeykovaY14}.
				\item	An similar approach on monitoring session types is also used for the
						Erlang programming language, which is a programming language for the Actors model.
			\end{itemize}

	\item	Pabble~\cite{DBLP:conf/pdp/NgY14} is an extension to Scribble used to express
			communication structures that have a parametrised number of roles.
			Pabble protocols are implemented and type-checked for the MPI framework.

	\item	Mungo~\cite{mungo} is a tool that integrates session types in the object-oriented
			programming paradigm through the typestate structure; communication
			interactions can be seen as an object interface with a behaviour.
			Mungo uses a protocol description language for capturing typestate.
			The tool Scribble to Mungo (StMungo) is used to transform Scribble
			protocols into Mungo protocols.


	\item	GV:			A functional programming implementation of binary session types.
	\item	LINKS:		Functional programming based on the linear logic interpretation of session types.
	\item	SILL:		Functional programming based on the linear dual intuitionistic interpretation of session types.

	\item	A state pattern implementation as a library. Uses Scribble to automatically
			create an API for state pattern programming and uses runtime checks to
			cope with linearity requirements.

\end{enumerate}

\subsection{Fine/coarse grain representation}
\dk{this should go as future work}

{\em Concurrency patterns} e.g. network topology, client/server, race condition, etc. (maybe I am writing nonsense here)

