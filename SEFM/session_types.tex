\section{Session Types}
%\label{sec:preliminaries}
\label{sec:session_types}


The section introduces session types through a
a discussion about the need of session types in
software engineering.
It also presents the Scribble~\cite{scribble} protocol
description language which is a formal language for describing
protocols using session type principles.
The overall discussion in this section identifies and sets
a clear and distinctive terminology needed to
for transferring to a wider audience the basic ideas of session
types.

\subsection{Session Types and Software Engineering}%: Notions and Terminology}
\label{sec:sessions_software}

\input{figures/fig-sequence_diagram}

Communication \emph{protocols} in software engineering
are usually described and communicated among humans
by using the most intuitive graphical form of sequence charts
(see \figref{seqchart}).
Sequence charts are used to depict communication flow as ordered
sequence of communication \emph{message passing} among communicating
participants that represent particular \emph{roles} in communication
protocol.

In \figref{seqchart}, the case of the Book-store protocol, which is a use-case
in the ABCD online repository~\cite{usecase_repository},  is presented.
The Book-store protocol specifies an interaction between two online Buyer roles
that invoke a process of buying a book from an online Seller role, while
sharing the expenses.
In the sequence chart, each role is represented with vertical line and
communication messages are represented with horizontal directed arrows
indicating the direction of communication flow.
Intuitively, the communication progress is proceeds downwards.
Thus, visually the protocol behaviour is represented within the chart.
However, sequence charts are not considered as formal tools because
such described protocols can not be verified as being complete or unambiguous.

For example, in industrial practice, the communication protocols for
distributed software, are usually described in natural language and
discussed with help of the sequence charts.
%After that and with the help of sequence charts,
%the protocols are implemented between the communication components
%of the software.
%within the distributed software
%with specified communication protocol.
With the help of sequence charts,
each software module that participates in the
protocol communication implements
its \emph{local} software role within the protocol.
Usually the process of implementing the local specifications
may follow different possible solutions that are not directly
visible or they are even omitted from the sequence chart, due
to the complexity they will introduce.
%\dk{what is hidden? - overall structure of the protocol, logic on choices}
Another limitation of sequence charts, is the inability to deal with complex
communication protocols, such as the case where some roles
need to make subsequent choices between different communication behaviours
for the entire protocol.

A solution to manage communication complexity
is the introduction of \emph{structure} within the communication protocol.
Session types describes communication in a structured and rigorous fashion,
and is aiming to define concepts for structured communication
that should enable better mastering of communication complexity.

%describing communication protocols

%Session types can be seen as types that describe behaviour.
Typically, a type is broadly understood
as a meta-information concept, that is used to describe a class of a data.
Structures of types are used to describe data structures.
When types are structured as input/output requirements they
are used to describe functionality.
The combination of functionality and data structures give rise
to the \emph{object oriented} concepts of classes and interfaces.% of objects.
%
A session type extends %the above approaches of
the notion of a type to capture the communication behaviour in concurrent systems.
% definition of session types
{\em A session type is a type structure that describes a communication
	behaviour in terms of a series of send and receive %message passing
	interactions between a set of communicating entities and it is used
	to characterise data structures that are used to implement communication.}

The formal nature of session types enables to rigorously
reason about the communication properties of a system.
Session types particularly focus in the properties:
%
\begin{enumerate}[label=$\bullet$]
	\item	{\em Communication Safety}: Every execution state of the system has {\em safe} communication behaviour:
	%	
	\begin{itemize}
		\item	{\em Communication interaction match}:
				Every send (resp., select) operation has a corresponding receive (resp., branch) operation.
		\item	{\em Message (\mybf{Payload?}) type match}:
				The type of every message being send matches the type of the message expected to be receive.
		\item	{\em Deadlock-freedom}:
				Consequently, every message send will be eventually received.
	\end{itemize}
	
	\item	{\em Communication Progress}: Every state of the system conforms to a terminated protocol, or
			it will {\em progress} to a state with a safe communication behaviour.
\end{enumerate}
%
In addition, the structured nature of session types enables
a methodology of applying session types in the software 
engineering process.

\dk{make clear that it is a syntactic/static technique - in contrast to model checking}

The Scribble tool-chain~\cite{scribble} is a platform
that indents to serve as a core element in the process
of integrating the practical aspects of session types
in software engineering. The design of Scribble
draws directly from the session type principles and the properties,
as identified through rigorous study. The rest of the
section introduces the main terminology for session types
and, whenever appropriate, it presents these notions
using the Scribble tool-chain.

\subsection{Sessions as Protocols}%: The Scribble Protocol Description Language}
\label{sec:sessions_scribble}

%The Scribble tool-chain~\cite{scribble} is a tool that indents
%to serve as a core element in the process of integrating
%the practical aspects of session types in software engineering.
%The basic module of the Scribble
%tool-chain is the Scribble protocol description language,
%which is a syntax that expresses session type specifications.
%The design of the Scribble language draws directly from
%the principles of session types.

Practically, a session type can be seen as a formal
{\em specification} of a communication {\em protocol} among communicating {\em roles}.
The syntax for session types is defined on pairs of operations:
(i) the {\em send} and {\em receive} operation give rise to
the {\em message passing} interaction; and
(ii) the {\em select} and {\em branch} operators enable the
{\em choice} interaction.

Message passing is used for sending data from one role the another.
The data that are passed are described in terms of their type. Session
types can also support the case of {\em session delegation}
where a session type value, i.e.~a structure that implements communication,
is passed as a message.
Choice requires for a role to use a value called {\em label}
to select a communication behaviour among
a set of behaviours, called {\em branch}, offered by another role.
The choice interaction enables formal specifications that can
cover a more complex structure of communication and among all possible
cases that may happen, in contrast to the limiting structure of
a sequence diagram.
%The syntax for session types is defined on {\em send} and {\em receive},
%and {\em select} and {\em branch} operators.
%Sending and receiving data gives rise to the notion of {\em message passing}.
%In a session type messages are described via their types.
%The case where a session typed value is passed as a message is called {\em session delegation}.
%The interaction of select and branch defines the {\em choice} interaction.
%Choice requires for a role to use a value called {\em label}
%to select a communication behaviour out of a set of behaviours, called {\em branch},
%offered by another role.
%\textbf{Important is to note that branch and choice elements within the formal specification force
%the user to think among all possible cases that may happen within an session type.
%Comparing to sequence charts which are not formal and thus more error prone.}

Session types assume a {\em global} protocol that describes the
communication interaction of all the roles inside a concurrent system.
A global type enables a view of a system as a whole, instead of the 
approach that a concurrent system is a set of communicating modules.
The perspective of a global protocol through a single role
is called {\em local} protocol. The local protocol describes
the communication interaction of a single role with all other roles
in the system.

The relation between a global protocol and the
local protocols of its roles, is expressed
through the {\em projection} procedure;
% called {\em projection}.
%Projection to a role
%is a procedure that can be done
%can be done automatically;
given the global protocol and a role, projection
returns as a local protocol only the
interactions of the global protocol that are concerned with
the role.

The reverse procedure from projection is called {\em synthesis},
where a set of local protocols are composed together in a global
protocol.

\subsubsection{The Scribble Protocol Description Language}
The notions explained above are supported by the
Scribble protocol description language,
which is a syntax used to express session type specifications.
For the sake of example
consider part of the session type protocol for the Book-store
use-case as in \figref{scribble_bs}. 


\input{figures/fig-scribble_bookstore}

Line 1 of the upper protocol in \figref{scribble_bs} shows the
Scribble definition of the global protocol for the Book-store use-case.
The communication takes place
among roles the \BuyerOne, \BuyerTwo and \Seller. Line 2 demonstrates
the syntax of a message passing interaction; a message
of type \code{title} labelled with label \code{book} is send \lstinline|from|
role \BuyerOne \lstinline|to| role \Seller. In Scribble messages are
defined as a list of types annotated with a label.

In line 5 of the protocol 
%their properties
the usage of a choice interaction is presented,
where role \BuyerTwo makes an internal decision and selects
out a two possible outcomes, that are
expressed with the labels \code{agree} in line 5 or \code{quit} in line 6.
In  both cases roles \BuyerOne and \Seller respectively offer
alternative branches. The choice interaction requires that
Role \BuyerTwo informs roles \BuyerOne and role \Seller. All
three roles will then synchronise on the same choice.

\dk{describe the recursion construct?}

Line 1 of the bottom protocol defines the local protocol 
for \BuyerOne of the Book-store protocol. Role \BuyerOne
interacts with roles \BuyerTwo and \Seller. In essence,
the local protocol for role \BuyerOne is derived automatically
by stripping out all the irrelevant information with respect
to \BuyerOne from the global protocol.

\subsection{Integrating Session Types in Software Development: The Scribble Tool-chain}
\label{sec:sessions_integrate}

Apart from a protocol description language,
Scribble offers a tool-chain that 
integrates session types in the software
development process.

\input{figures/fig-sessions_software}

%Below the term system is used to describe the whole concurrent
%system and the term \dk{program} is used for communication module
%inside the system. \textbf{Bellow the term system is used to describe whole local protocol
%implementation as a set of communication modules it is composed of? }

\dk{The formal nature of session types protocols
	allow for rigorous manipulation of the communication behaviour.}

\figref{diagram} clarifies the terminology
developed previously by showing the
\mybf{typical usage} of session types in software
engineering.
%design and development. 
Furthermore, it distinguishes
the desirable properties that are offered by 
session types.

In \figref{diagram} circles
represent source code for either the software
under development (white coloured) or for the definition
of the session type protocols (grey coloured). 
The arrows
represent automated procedures that ensure
the desirable properties of session types
in the development process. The Scribble
tool-chain supports many of these automated
procedures.
An important assumption
is that the software source code in the
bottom of \figref{diagram} uses an interface
for communication, where the communication
operations can be identified by automated
procedures.

In a typical top-down approach, a developer will first develop a global protocol
%and express it syntactic form. 
as syntax that expresses session type specifications.
This for example can be done
using the Scribble protocol description language.
The global protocol source code is shown
on the top of \figref{diagram}.
The next step is to run a procedure to verify the 
global protocol correctness \dk{what does it verify?}.
After the global protocol verification, a projection
procedure takes place where a local protocol
for each global protocol role is derived.
The obtained local protocols are also expressed
syntactically as session type specifications.
Verification, projection and local specification
syntax are supported by the Scribble tool-chain.

One way to use the set of local protocols is to ensure
conformance between the source code of the
software under development and the local protocols,
by using a type-checker procedure.
%To achieve this there is the assumption that
%the programming language used to develop the
%software source code, makes use of a communication
%interface that can be identified by a type-checker
%procedure.
The type-checker takes as an input
%software module,
source code that corresponds to a communicating process;
it identifies its communication operations,
and derives the communication behaviour of
the
%module. 
source code.
The type-checker also takes as an input the
corresponding syntax of the local protocol 
and checks whether the 
%software module
software source code
implements the corresponding role of the specified communication behaviour.
Upon success, the result is verified software that
enjoys the session types {\em communication safety} and {\em communication progress}
properties.


A second way to use the set of local protocols
is for automatic code generation. The generated
code might be in the form of APIs that implement
communication behaviour or in the form of programming
templates that implement communication behaviour and
they further need attention by the developers for adding
extra computational logic.
Scribble supports the generation of a Java API out of
every the set of Scribble local protocols.
The generated API has a class for each state of the protocol
that implements as methods all the available communication
operations. A call to method returns an object of the class
that corresponds to the next state of the protocol. A dynamic
check ensures that each object (i.e.~state) is used once.


Another way of using the set of local protocols is
for monitoring the execution of the communication
interaction inside a concurrent system.
The local protocols are used to feed a set of local monitors.
Essentially, the local monitors run a state machine that is derived
out of the local protocol syntax.
%The monitor platform also requires for
%the concurrent software execution.
It is assumed that the communication interaction
of the software under execution can be recognised
and monitored by the monitor interface.
%The assumption to be made here is that
%monitor platform implements the communication interface
%on top of the monitoring interface. \textbf{I do not understand this sentence!}
Scribble does support the procedure of deriving
state machines out of local protocol syntax.

\figref{diagram} 
%there is 
presents the bottom-up approach as well,
were the communicating 
%modules of a concurrent software
software source codes
are developed independently.
Then an inference  procedure identifies the communication behaviour
of each
%\textbf{Term module is never defined but used frequently. In previous
%sentences you used source code. What is relation?}
communication process that results in a set of local protocols.
%\textbf{Here is not clear - if this is provided automatically?}.
Then an automatic synthesis procedure can take place,
where the derived local protocols are synthesised
to create a global protocol. Upon success, the
developed software is guaranteed to ensure
the communication safety and progress.


In any of the above methodologies for using session types,
session types can be used as requirements by humans means
to drive the software development process. In the top-down
approach local types can be used to give intuition and guide
developers when implementing code.
Furthermore, the bottom-up approach more agile development teams
can analyse and compare the obtained global and/or local protocols
against the intended communication behaviour using human
reading techniques.

\dk{how about diagrammatic languages?}




%\textbf{Furthermore, thus obtained global protocol can be compared 
%to the specifications of intended communication behaviour, 
%formally with tools or informally with human reading technique.}

%Typically, a protocol is first expressed globally and then
%projected locally \textbf{on each protocol role, projecting one local protocol specification per each protocol role.}
%Local specifications are then implemented by the corresponding
%\mybf{programs}.
%The term {\em session fidelity} is used to express
%the conformance of a \mybf{program}, to the local protocol of the
%corresponding role. Session fidelity can be checked mechanically,
%through techniques like type-checking and monitoring.

The case where the implementation of all the communication
processes inside a system conforms to the corresponding
local protocols of all the roles in a global protocol 
%are implemented by the corresponding communicating modules of
is called {\em session fidelity}.
When session fidelity is ensured then the communication safety
and communication progress properties are ensured.
%then a number of communication properties can be guaranteed
%for the concurrent software:
%%
%\begin{enumerate}[label=$\bullet$]
%	\item	Every execution state of the system has {\em safe} communication behaviour:
%	%	
%	\begin{itemize}
%		\item	{\em Communication interaction match}: Every send (resp., select) operation has a corresponding receive (resp., branch) operation.
%		\item	{\em Message (\mybf{Payload?}) type match}: The type of every message being send matches the type of the message expected to be receive.
%		\item	{\em Deadlock-freedom}: Consequently, every message send will be eventually received.
%	\end{itemize}
%	
%	\item	Every state of the system conforms to a terminated protocol, or
%			it will {\em progress} to a state with a safe communication behaviour.
%\end{enumerate}

As seen in \figref{diagram} Scribble and the procedures
that manipulate session type protocols lie at the core
of the software development process. This is also clarified
by the experience in developing the usecases for the ABCD
online repository. The Scribble platform and its procedures
has an independent status next to the plethora of technologies and
programming paradigms used in the case studies.

%\subsection{Session Types as Protocols: The Scribble Tool-chain}
%
%This section presents the Scribble~\cite{scribble} tool-chain
%as the core tool for the application of session types.
%This section also uses Scribble to clarify the terminology
%developed in the previous section.

%The basic module of the Scribble tool-chain is the
%Scribble protocol description language,
%which is a syntax that expresses session type specifications.
%The design of the Scribble language draws directly from
%the principles of session types.

%\input{figures/fig-scribble_global_bookstore}

%In \figref{scribble_bs}, uses the Scribble protocol for the
%Bookstore usecase in the online repository~\cite{usecase_repository},
%to present the Scribble syntax.
%Line 1 defines the 
%of global protocol \lstinline|Bookstore| between
%roles \lstinline|Buyer1|, \lstinline|Buyer2| and \lstinline|Seller|.
%%The communication structure is expressed 
%%as a sequence of {\em endpoint} to endpoint message passing
%%interactions between the roles of the protocol.
%%Messages are described in terms of a message type,
%%where  a label is used to annotate a list
%%of types.
%Line 2 gives an example of the simplest endpoint-to-endpoint
%message passing interaction,
%where a message with
%label \lstinline|book| and type \lstinline|title| (notation \lstinline|book(title)|)
%is send from (keyword \lstinline|from|) role \lstinline|Buyer1| to (keyword \lstinline|to|)
%role \lstinline{Seller}.
%In Scribble messages are described as a type structure
%consisted of a label and a list of message types.


%Line 5 of the protocol clarifies the choice interaction, where
%role \lstinline|Buyer2| selects a choice from two possible outcomes,
%expressed with the labels \lstinline|agree| or \lstinline|quit|. In 
%both cases roles \lstinline|Buyer1| and \lstinline|Seller| offer
%alternative branches.


%\input{figures/fig-scribble_local_bookstore}

%We use the term {\em local} protocol to describe
%the communication structure at the level of a single participant.
%As session types is a type discipline with the requirement to
%be enforced on a program, we may sometimes refer to a session type
%protocol as communication {\em specification}.

%For example Scribble code:
%%
%\begin{lstlisting}
%  msg(int) from A to B;
%\end{lstlisting}
%%
%describes the global protocol between role \lstinline|A| and \lstinline|B|,
%where participant \lstinline|A| sends message of type \lstinline|msg(int)|
%to participant \lstinline|B|. From the local perspective of participant
%\lstinline|A| the protocol would be:
%%
%\begin{lstlisting}
%  msg(int) to B;
%\end{lstlisting}
%%
%where it describes the sending of message \lstinline|msg(int)|
%to participant \lstinline|B|.


\subsection{Usecase Classification on Technologies used}
\dk{Just presentation and references}

The technologies used to implement the demonstrated usecases are presented
below:
%
\begin{enumerate}
	\item	Session Java~\cite{HU07TYPE-SAFE} is the first tool
			developed as a tool with a library that support binary session
			types. The tool requires compiler support to perform session
			type-check.

	\item	The Eventful Session Java~\cite{event} is an extension
			of session types to support asynchronous, event-driven programming.

	\item	Multiparty Session C~\cite{NYH12}
			is the first tool that implemented a
			multiparty session type library for MPI.
			The tool requires compiler support to perform session
			type-check.


	\item	Session fidelity can also be ensured using runtime monitoring.
			Modules for monitoring were implemented in python and are presented in~\cite{DBLP:conf/rv/NeykovaYH13}.

	\item	Session types are embedded in the Actors paradigm in the following technologies:
			\begin{itemize}
				\item	An implementation that uses the python monitoring module for session types to
						monitor python threads that simulate actors~\cite{DBLP:conf/coordination/NeykovaY14}.
				\item	An similar approach on monitoring session types is also used for the
						Erlang programming language, which is a programming language for the Actors model.
			\end{itemize}

	\item	Pabble~\cite{DBLP:conf/pdp/NgY14} is an extension to Scribble used to express
			communication structures that have a parametrised number of roles.
			Pabble protocols are implemented and type-checked for the MPI framework.

	\item	Mungo~\cite{mungo} is a tool that integrates session types in the object-oriented
			programming paradigm through the typestate structure; communication
			interactions can be seen as an object interface with a behaviour.
			Mungo uses a protocol description language for capturing typestate.
			The tool Scribble to Mungo (StMungo) is used to transform Scribble
			protocols into Mungo protocols.


	\item	GV:			A functional programming implementation of binary session types.
	\item	LINKS:		Functional programming based on the linear logic interpretation of session types.
	\item	SILL:		Functional programming based on the linear dual intuitionistic interpretation of session types.

	\item	A state pattern implementation as a library. Uses Scribble to automatically
			create an API for state pattern programming and uses runtime checks to
			cope with linearity requirements.

\end{enumerate}

\subsection{Fine/coarse grain representation}
\dk{this should go as future work}

{\em Concurrency patterns} e.g. network topology, client/server, race condition, etc. (maybe I am writing nonsense here)
